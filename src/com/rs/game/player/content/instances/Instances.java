package com.rs.game.player.content.instances;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;

import com.rs.cores.CoresManager;
import com.rs.game.RegionBuilder;
import com.rs.game.World;
import com.rs.game.WorldTile;
import com.rs.game.npc.NPC;
import com.rs.game.npc.godwars.GodwarsInstanceBoss;
import com.rs.game.player.Player;
import com.rs.game.player.controlers.Controler;
import com.rs.game.player.controlers.GodWars;
import com.rs.game.tasks.WorldTask;
import com.rs.game.tasks.WorldTasksManager;

public final class Instances implements Serializable {
	
	private static final long serialVersionUID = 1L;
	
	private final ArrayList<Player> instance_players;
	private final ArrayList<NPC> instance_npcs;
	private final Player owner;
	public static final int DEFAULT_SIZE = 1, MAX_SIZE = 100, GODWARS_THRESHOLD = InstancedEncounter.SARADOMIN.ordinal();//3;
	private final InstancedEncounter instance;
	private final RespawnDelay respawnDelay;
	private final Visibilities visibility;
	private final String password;
	public final String owner_name;
	private Stages stage;
	private int[] regionBase;
	private int ticks;
	public static final boolean DEBUG = false;
	//TODO must change gwd minions to allow for proper spawning when in instance
	//TODO allow tick refilling from other players for a price
	
	public static final HashMap<Integer, InstancedEncounter> VALID_INSTANCES = new HashMap<Integer, InstancedEncounter>();
	public static final HashMap<Integer, InstancedEncounter> INSTANCE_EXITS = new HashMap<Integer, InstancedEncounter>();
	public static final ConcurrentHashMap<String, Instances> ACTIVE_INSTANCES = new ConcurrentHashMap<String, Instances>();
	
	public final InstancedEncounter getInstance() {
		return instance;
	}
	
	public static final boolean isValidInstance(final int objectId) {
		return VALID_INSTANCES.get(objectId) != null;
	}
	
	public static final boolean isInstanceExit(final int objectId) {
		return INSTANCE_EXITS.get(objectId) != null;
	}
	
	public static final boolean activeInstanceExists(String username) {
		return ACTIVE_INSTANCES.get(username.toLowerCase()) != null;
	}
	
	static {
		for (final InstancedEncounter instances : InstancedEncounter.values()) {
			if (instances == null)
				continue;
			if (instances.getEntranceObjectId() != -1)
				VALID_INSTANCES.put(instances.getEntranceObjectId(), instances);
			if (instances.getExitObjectId() != -1)
				INSTANCE_EXITS.put(instances.getExitObjectId(), instances);
		}
		WorldTasksManager.schedule(new WorldTask() {
			@Override
			public void run() {
				if (DEBUG) {
					final int size = ACTIVE_INSTANCES.size();
					System.out.println("<col=ff00ff>Iterating over: "+size+" active instances!");
				}
				for (final String key : ACTIVE_INSTANCES.keySet()) {
					if (key == null)
						continue;
					final Instances instance = ACTIVE_INSTANCES.get(key);
					if (instance == null || instance.stage != Stages.RUNNING)
						continue;
					/**
					 * Handles the destruction of an instance and allows for the instance to be processed every minute.
					 */
					instance.process();
				}
			}
		},100,100);
	}
	
	public enum RespawnDelay {
		FAST,MEDIUM,SLOW
	}
	
	public enum Visibilities {
		PRIVATE,PUBLIC
	}
	
	private enum Stages {
		LOADING,RUNNING,DESTROYING
	}
	
	public Instances(final Player player, final InstancedEncounter instance, final RespawnDelay duration, final Visibilities visibility) {
		this(player,instance,duration,visibility, null);
	}
	
	public Instances(final Player player, final InstancedEncounter instance, final RespawnDelay respawnDelay, final Visibilities visibility, final String password) {
		this.owner = player;
		this.instance = instance;
		this.respawnDelay = respawnDelay;
		this.visibility = visibility;
		this.password = password;
		this.instance_players = new ArrayList<Player>();
		this.instance_npcs = new ArrayList<NPC>();
		if (!instance_players.contains(player))
			instance_players.add(owner);
		this.owner_name = owner.getDisplayName().toLowerCase();
		this.ticks = 60;
		ACTIVE_INSTANCES.put(owner_name, this);
		this.stage = Stages.LOADING;
		player.getControlerManager().startControler("InstanceController", this);
		generateInstance();
		if (DEBUG)
			System.err.println("A new "+instance.toString().toLowerCase()+" instance has been generated by "+owner_name+".");
	}
	
	public final void joinInstance(final Player player, final String pass) {
		if (stage != Stages.RUNNING) {
			if (stage == Stages.LOADING)
				player.getPackets().sendGameMessage("The instance you requested has not loaded yet. Please wait and try again shortly.");
			else
				player.getPackets().sendGameMessage("The instance you requested is currently being destroyed.");
			return;
		}
		if (owner != null && player != owner) {
			if (visibility != Visibilities.PUBLIC) {
				player.getPackets().sendGameMessage(owner_name+"'s instance is private.");
				return;
			}
			final int size = instance_players.size();
			if (size >= MAX_SIZE) {
				player.getPackets().sendGameMessage(owner_name+"'s instance is only capable of holding "+MAX_SIZE+" players.");
				return;
			}
			if (password != null) {
				if (pass == null || !password.equals(pass)) {
					player.getPackets().sendGameMessage("You've entered the incorrect password for "+owner_name+"'s instance.");
					return;
				}
			}
		}
		addPlayer(player);
	}
	
	private final void addPlayer(Player player) {
		if (stage != Stages.RUNNING || instance_players == null)
			return;
		if (instance_players.contains(player)) {
			player.getPackets().sendGameMessage("There was an error when adding you to the instance! Error: <col=ff0000>PLAYER_ALREADY_WITHIN_INSTANCE</col>.");
			return;
		}
		instance_players.add(player);
		player.setForceMultiArea(true);
		player.setNextWorldTile(getWorldTile(instance.getLocation()[0], instance.getLocation()[1]));
		player.getControlerManager().startControler("InstanceController", this);
	}
	
	public final int getTimeRemaining() {
		return ticks;
	}
	
	protected final void generateInstance() {
		if (stage != Stages.LOADING)
			return;
		owner.lock();
		CoresManager.slowExecutor.execute(new Runnable() {
			@Override
			public void run() {
				regionBase = RegionBuilder.findEmptyChunkBound(8, 8); 
				RegionBuilder.copyMap(instance.getRegionCoordinates()[0], instance.getRegionCoordinates()[1], regionBase[0], regionBase[1], 8, 8,new int[] {0},new int[]{0});//8);
				owner.setNextWorldTile(getWorldTile(instance.getLocation()[0], instance.getLocation()[1]));
				WorldTasksManager.schedule(new WorldTask()  {
					@Override
					public void run() {
						owner.setForceMultiArea(true);
						owner.unlock();
						stage = Stages.RUNNING;
						messageInstancePlayers("The instance will last for another "+getTimeRemaining()+" minutes.");
						if (instance.getNPCs() != null && instance.getNPCs().length > 0) {
							GodwarsInstanceBoss boss = null;
							final int ordinal = instance.ordinal();
							for (int index = 0; index < instance.getNPCs().length; index++) {
								final InstanceNPC npc = instance.getNPCs()[index];
								if (npc == null)
									continue;
								/**
								 * The last parameter of the spawnNPC method denotes that the godwars npcs are seperated from the static, non-instantiable
								 * variants and therefore prevents collision between the GWD instances and non-instantiated GWD
								 */
								final NPC n = World.spawnNPC(npc.getNPCId(), getWorldTile(npc.getXOffset(), npc.getYOffset()), -1, true, false, true);
								n.setForceMultiArea(true);
								n.respawnDelay = respawnDelay;
								instance_npcs.add(n);
								if (ordinal <= GODWARS_THRESHOLD) {
									if (index == 0) {
										if (n instanceof GodwarsInstanceBoss)
											boss = (GodwarsInstanceBoss) n;
									} else {
										if (boss != null) {
											if (boss.minions != null && !boss.minions.contains(n))
												boss.minions.add(n);
										}
									}
								}
							}
						}
					}
				}, 1);
			}
		});
	}
	
	private final void messageInstancePlayers(final String message) {
		if (stage != Stages.RUNNING || instance_players == null || instance_players.isEmpty())
			return;
		for (final Iterator<Player> it = instance_players.iterator(); it.hasNext();) {
			final Player player = it.next();
			if (player == null || player.hasFinished() || !player.hasStarted() || !player.isRunning()) {
				it.remove();
				continue;
			}
			player.getPackets().sendGameMessage(message, true);
		}
	}
	
	protected final void checkPlayers() {
		if (stage != Stages.RUNNING || instance_players == null || instance_players.isEmpty())
			return;
		for (final Iterator<Player> it = instance_players.iterator(); it.hasNext();) {
			final Player player = it.next();
			if (player == null || player.hasFinished() || !player.hasStarted() || !player.isRunning()) {
				it.remove();
			}
		}
	}
	
	protected final void process() {
		if (stage != Stages.RUNNING)
			return;
		ticks--;
		checkPlayers();
		if (ticks != 0 && ticks % 10 == 0)
			messageInstancePlayers("The instance you're within has "+getTimeRemaining()+" minutes remaining before it collapses.");
		final boolean contains_players = instance_players != null && !instance_players.isEmpty();
		if (ticks <= 0 || !contains_players) {
			destroyInstance(contains_players);
		}
	}
	
	protected final void forcefullyDestroyInstance() {
		if (stage == Stages.DESTROYING)
			return;
		stage = Stages.DESTROYING;
		messageInstancePlayers("<col=ff0000>The instance you were within has been reassigned by "+owner_name+"!");
		removeAllPlayers(true);
		removeAllNpcs();
		destroyRegion();
		regionBase = null;
		ACTIVE_INSTANCES.remove(owner_name);
		if (DEBUG)
			System.err.println("Forcefully removed the instance of: "+owner_name);
	}
	
	protected final void destroyInstance(final boolean remove) {
		if (stage == Stages.DESTROYING)
			return;
		stage = Stages.DESTROYING;
		if (remove) {
			messageInstancePlayers("<col=ff0000>The instance you were within has collapsed!");
			removeAllPlayers(false);
		}
		removeAllNpcs();
		destroyRegion();
		regionBase = null;
		ACTIVE_INSTANCES.remove(owner_name);
		if (DEBUG)
			System.err.println("Destroyed the instance of: "+owner_name);
	}
	
	private final void removeAllNpcs() {
		if (stage != Stages.DESTROYING || instance_npcs == null || instance_npcs.isEmpty())
			return;
		for (Iterator<NPC> it = instance_npcs.iterator(); it.hasNext();) {
			final NPC npc = it.next();
			if (npc != null)
				npc.finish();
			it.remove();
		}
		if (!instance_npcs.isEmpty())
			instance_npcs.clear();
	}
	
	private final void destroyRegion() {
		if (stage != Stages.DESTROYING || regionBase == null)
			return;
		CoresManager.slowExecutor.schedule(new Runnable() {
			@Override
			public void run() {
				RegionBuilder.destroyMap(regionBase[0] , regionBase[1] , 8, 8);
			}
		}, 1200, TimeUnit.MILLISECONDS);
	}
	
	public final void removePlayer(final Player player, final boolean death) {
		if (instance_players == null || instance_players.isEmpty())
			return;
		if (instance_players.contains(player))
			instance_players.remove(player);
		if (!death) {
			final Controler controller = player.getControlerManager().getControler();
			if (controller != null) {
				controller.removeControler();
			}
			player.setNextWorldTile(instance.getExitTile());
			if (instance.ordinal() <= GODWARS_THRESHOLD && !(player.getControlerManager().getControler() instanceof GodWars))
				player.getControlerManager().startControler("GodWars");
		}
	}
	
	private final void removeAllPlayers(final boolean leaveOwner) {
		if (stage != Stages.DESTROYING || instance_players == null || instance_players.isEmpty())
			return;
		for (final Iterator<Player> it = instance_players.iterator(); it.hasNext();) {
			final Player player = it.next();
			if (player == null || player.hasFinished() || !player.hasStarted() || !player.isRunning()) {
				it.remove();
				continue;
			}
			final Controler controller = player.getControlerManager().getControler();
			if (controller != null) {
				controller.removeControler();
			}
			if (leaveOwner) {
				if (owner != null && player != owner)
					player.setNextWorldTile(instance.getExitTile());
			} else
				player.setNextWorldTile(instance.getExitTile());
			if (!(player.getControlerManager().getControler() instanceof GodWars))
				player.getControlerManager().startControler("GodWars");
			it.remove();
		}
		if (!instance_players.isEmpty())
			instance_players.clear();
	}
	
	private final WorldTile getWorldTile(final int mapX, final int mapY) {
		final WorldTile tile = new WorldTile(regionBase[0]*8 + mapX, regionBase[1]*8 + mapY, 0);
		if (DEBUG) {
			System.err.println("TileX: "+tile.getX()+", TileY: "+tile.getY());
		}
		return tile;
	}
	
}
